# 开发日志

## 2026-01-20
### 需求拆解与边界界定
- 将问题拆为“接收通知”和“投递执行”两个核心用例，并补充“持久化与重试”为基础子能力，作为系统可靠性的核心。
- 明确系统边界：统一接入、可靠投递、状态可追踪；不做协议编排、精确一次、运营后台等，避免不必要复杂度。
- 形成设计文档 `wiki/design.md`，补充 DB 设计与接口定义，确保后续实现有清晰边界。

### 架构选择与取舍
- 初期方案采用数据库任务表 + 定时扫描的调度方式，理由是实现简单、易维护，足够支撑 MVP。
- 对于消息中间件的取舍，通过沟通确认“不上 Kafka”，原因是延迟调度/编排问题会引入额外复杂度；未来量大时优先考虑 Redis 延迟队列。
- 可靠性语义选择“至少一次”，平衡可实现性与工程复杂度，避免引入分布式事务。

### AI 使用与人类判断
- AI 提供了架构草图、可靠性策略、演进方向建议，但在沟通后进行筛选与修正：
  - 未采纳：第一版引入 Kafka、复杂退避策略与调度配置。原因是 MVP 不需要且会增加后续编排场景的复杂度。
  - 采纳并调整：保留指数退避的概念，但决定 MVP 直接使用 `spring-retry` 简化实现，后续再做配置化。
- 明确区分 AI 输出与人类决策：在 README 中体现“取舍对比”与“未采纳建议”。

### 实现与验证
- 采用 jOOQ 作为数据访问方案，切换掉 JPA 实体，避免模型重复与生成代码不一致问题。
- 数据库 schema 改为自增 ID，并调整仓储逻辑为 `returning()` 获取主键。
- 添加 TS 脚本 `scripts/verify.ts` 用于验证“接收通知”主流程，最终验证成功。
- 为 MVP 验证阶段将投递逻辑改为 mock 成功，强调“可验证”优先于“复杂投递”。

### 工程经验体现
- 通过“先 DB、后 Redis”的演进路线，拒绝引入 kafka 的提议，体现对复杂度与交付节奏的管理。
- 用清晰的边界与取舍说明回应题目关注点，确保评估重点可被直接读到。
- 将 AI 建议与最终决策分离记录，突出判断与取舍能力。
